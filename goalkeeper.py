import numpy as np
import cv2
import argparse
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from config import color_range
import data_predict

ap = argparse.ArgumentParser(description='–•–æ–∫–∫–µ–π–Ω—ã–π –≤—Ä–∞—Ç–∞—Ä—å. –û—Ç–±–∏–≤–∞–µ—Ç —à–∞–π–±—ã –ø–æ –ª—å–¥—É. –ü—Ä–∏ —É—Å–ª–æ–≤–∏–∏. —á—Ç–æ —à–∞–π–±–∞ –¥–≤–∏–∂–µ—Ç—Å—è –ø–æ –ø—Ä—è–º–æ–π.')
ap.add_argument("-c", "--coordinat", type = int, required = False, help="–í—ã–≤–æ–¥ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω–æ–π –æ—Å–∏.")
ap.add_argument("-p", "--predict", type = int, required = False, help="–ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –¥–ª—è –≤–≤–µ–¥–µ–Ω–Ω–æ–≥–æ —á–∏—Å–ª–∞ X.")
ap.add_argument("-r", "--range", type = int, required = False, help="–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ RGB.")
ap.add_argument("-b", "--ball", type = int, required = False, help="–ü–æ–∏—Å–∫ –º—è—á–∞.")
args = vars(ap.parse_args())

# –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –ø–æ —Ü–≤–µ—Ç—É
def range(camera):

    def nothing(x):
        pass

    cap = cv2.VideoCapture(camera)
    cv2.namedWindow('result')

    cv2.createTrackbar('minb', 'result', 0, 255, nothing)
    cv2.createTrackbar('ming', 'result', 0, 255, nothing)
    cv2.createTrackbar('minr', 'result', 0, 255, nothing)

    cv2.createTrackbar('maxb', 'result', 0, 255, nothing)
    cv2.createTrackbar('maxg', 'result', 0, 255, nothing)
    cv2.createTrackbar('maxr', 'result', 0, 255, nothing)

    while(cap.isOpened()):
        _, frame = cap.read()
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        cv2.imshow('hsv', hsv)

        minb = cv2.getTrackbarPos('minb', 'result')
        ming = cv2.getTrackbarPos('ming', 'result')
        minr = cv2.getTrackbarPos('minr', 'result')

        maxb = cv2.getTrackbarPos('maxb', 'result')
        maxg = cv2.getTrackbarPos('maxg', 'result')
        maxr = cv2.getTrackbarPos('maxr', 'result')

        mask = cv2.inRange(hsv, (minb, ming, minr), (maxb, maxg, maxr))
        cv2.imshow('mask', mask)
        result = cv2.bitwise_and(frame, frame, mask = mask)
        cv2.imshow('result', result)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            # –∑–∞–ø–∏—Å—å –≥—Ä–∞–Ω–∏—Ü –æ–ª–∞—Å—Ç–∏ —Ü–≤–µ—Ç–∞ –≤ —Ñ–∞–π–ª
            handle = open("config/color_range.py", "w")
            handle.write("MINB = " + str(minb) + "\n"
                        "MING = " + str(ming) + "\n"
                        "MINR = " + str(minr) + "\n"
                        "MAXB = " + str(maxb) + "\n"
                        "MAXG = " + str(maxg) + "\n"
                        "MAXR = " + str(maxr))
            handle.close()
            break

    cap.release()
    cv2.destroyAllWindows()

# –õ–∏–Ω–µ–π–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è
def predict(X):
    # –ø—Ä—è–º–∞—è –ª–∏–Ω–∏—è –æ—Ç (0,0) –¥–æ (10,10)
    # –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ x –≤ –¥–≤—É–º–µ—Ä–Ω—ã–π –º–∞—Å—Å–∏–≤, —Ç.–µ. 1 –∫–æ–ª–æ–Ω–∫–∞ –∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä—è–¥–æ–≤
    #x = np.array([1, 2, 4, 5, 6, 8, 10])
    #y = np.array([1, 2, 4, 5, 6, 8, 10])
    # –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –µ—â–µ –ø–æ –æ–¥–Ω–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É
    #x=np.append(x,15).reshape((-1, 1))
    #y=np.append(y,15)

    # –Ω–∞–ø–æ–ª–Ω—è–µ–º –º–∞—Å—Å–∏–≤—ã –¥–∞–Ω–Ω—ã–º–∏ –∏–∑ —Ñ–∞–π–ª–∞
    x = np.array(data_predict.X).reshape((-1, 1))
    y = np.array(data_predict.Y)

    # –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –≥—Ä–∞—Ñ–∏–∫
    plt.plot(x, y)
    plt.show()

    print(x)
    print(y)

    # —Å–æ–∑–¥–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    # .fit() - –≤—ã—á–∏—Å–ª—è—é—Ç—Å—è –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤–µ—Å–æ–≤ ùëè‚ÇÄ –∏ ùëè‚ÇÅ
    model = LinearRegression().fit(x,y)

    # .score() –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –ø—Ä–µ–¥—Å–∫–∞–∑–∞—Ç–µ–ª—å x –∏ —Ä–µ–≥—Ä–µ—Å—Å–æ—Ä y, –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ ùëÖ¬≤.
    r_sq = model.score(x,y)
    print('coefficient of determination:', r_sq)

    # model —Å–æ–¥–µ—Ä–∂–∏—Ç –∞—Ç—Ä–∏–±—É—Ç—ã .intercept_, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç, –∏ ùëè‚ÇÄ —Å .coef_, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç ùëè‚ÇÅ:
    # –ø–æ–ª—É—á–µ–Ω–∏–µ ùëè‚ÇÄ –∏ ùëè‚ÇÅ
    # .intercept_ ‚Äì —ç—Ç–æ —Å–∫–∞–ª—è—Ä, –≤ —Ç–æ –≤—Ä–µ–º—è –∫–∞–∫ .coef_ ‚Äì –º–∞—Å—Å–∏–≤
    # –ø—Ä–∏–º–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ ùëè‚ÇÄ = -8.881784197001252e-16 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –Ω–∞—à–∞ –º–æ–¥–µ–ª—å –ø—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ—Ç –æ—Ç–≤–µ—Ç -8.881784197001252e-16 –ø—Ä–∏ ùë•, —Ä–∞–≤–Ω—ã–º –Ω—É–ª—é. –†–∞–≤–µ–Ω—Å—Ç–≤–æ ùëè‚ÇÅ = 1. –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç –≤–æ–∑—Ä–∞—Å—Ç–∞–µ—Ç –¥–æ 1 –ø—Ä–∏ ùë•, —É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–º –Ω–∞ –µ–¥–∏–Ω–∏—Ü—É.
    print('intercept (b0):', model.intercept_)
    print('slope (b1):', model.coef_)

    # –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
    # –æ—Ü–µ–Ω–æ—á–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Ä–µ–≥—Ä–µ—Å—Å–∏–∏ –≤—ã—Ä–∞–∂–∞–µ—Ç—Å—è —É—Ä–∞–≤–Ω–µ–Ω–∏–µ–º ùëì(ùë•) = ùëè‚ÇÄ + ùëè‚ÇÅùë•
    # y_pred = model.predict(x)
    # –∏–ª–∏
    # y_pred = model.intercept_ + model.coef_ * x

    # –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –¥–ª—è x = 23
    #x0 = np.array([23]).reshape((-1, 1))
    x0 = np.array([X]).reshape((-1, 1))
    y_pred = model.predict(x0)
    print('–ü—Ä–∏ X =', int(x0))
    print('–ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –¥–ª—è Y =', int(y_pred))

# –ü–æ–∏—Å–∫ –º—è—á–∞
def ball(image, img):
    output = image.copy()
    #gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(output, (5, 5), 0)
    blur = cv2.GaussianBlur(blur, (5, 5), 0)
    canny = cv2.Canny(blur, 40, 10)
    # –ø–æ—Å–∏–∫ –∫—Ä—É–≥–∞
    circles = cv2.HoughCircles(canny, cv2.HOUGH_GRADIENT, 2.5, 57)
    #circles = cv2.HoughCircles(output,cv2.HOUGH_GRADIENT,1,20,param1=20,param2=20,minRadius=30,maxRadius=400)
    #print(circles)
    # –µ—Å–ª–∏ –Ω–∞–π–¥–µ–Ω—ã –∫—Ä—É–≥–∏
    if circles is not None:
    	# –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã (x, y) –∏ —Ä–∞–¥–∏—É—Å–∞ –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–µ–π –≤ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞
    	circles = np.round(circles[0, :]).astype("int")

    	# –û–±–≤–µ—Å—Ç–∏ –Ω–∞–π–¥–µ–Ω—ã–π –∫—Ä—É–≥ –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å—é –∏ –Ω–∞—Ä–∏—Å–æ–≤–∞—Ç—å –∫–≤–∞–¥—Ä–∞—Ç –≤ —Ü–µ–Ω—Ç—Ä–µ –∫—Ä—É–≥–∞
    	for (x, y, r) in circles:
    		cv2.circle(img, (x, y), r, (0, 0, 255), 4)
    		cv2.rectangle(img, (x - 5, y - 5), (x + 5, y + 5), (0, 255, 255), -1)
    #cv2.putText(img, "%d-%d" % (x,y), (x+10,y-10), cv2.FONT_HERSHEY_SIMPLEX, 1, (0,255,255), 2)

    	#cv2.imshow("output", np.hstack([image, output]))

    return(img)

# –º–∞—Å—Å–∏–≤—ã –¥–ª—è –ª–∏–Ω–µ–π–Ω–æ–π —Ä–µ–≥—Ä–µ—Å—Å–∏–∏
def array(x, y):
    # –Ω–∞–ø–æ–ª–Ω—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ —Ü–µ–Ω—Ç—Ä–∞
    data_x.append(x)
    data_y.append(y)
    #print('X', data_x)
    #print('Y', data_y)

    # –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø–∏—Å–µ–π/–∑–∞–º–µ—Ä–æ–≤
    # –µ—Å–ª–∏ np.array(data_x).shape = 20 —Ç–æ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
    print(np.array(data_x).shape[0])
    if np.array(data_x).shape[0] == 20 or np.array(data_y).shape[0] == 20:
            handle = open("data_predict.py", "w")
            handle.write("X = " + str(data_x) + "\n"
                        "Y = " + str(data_y))
            handle.close
    #print(np.array(data_x).shape)

# –í—ã–¥–µ–ª–µ–Ω–∏–µ –ø–æ —Ü–≤–µ—Ç—É
def color(img, hsv_min, hsv_max):

    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    thresh = cv2.inRange(hsv, hsv_min, hsv_max)
    '''
    # –ú–æ–º–µ–Ω—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è ‚Äî —ç—Ç–æ —Å—É–º–º–∞—Ä–Ω–∞—è —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞ –ø—è—Ç–Ω–∞, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∞—è —Å–æ–±–æ–π —Å—É–º–º—É –≤—Å–µ—Ö —Ç–æ—á–µ–∫ (–ø–∏–∫—Å–µ–ª–µ–π) —ç—Ç–æ–≥–æ –ø—è—Ç–Ω–∞.
    moments = cv2.moments(thresh, 1)
    # –ú–æ–º–µ–Ω—Ç –ø–µ—Ä–≤–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ m10 –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π —Å—É–º–º—É Y –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —Ç–æ—á–µ–∫
    dM01 = moments['m01']
    # –ú–æ–º–µ–Ω—Ç –ø–µ—Ä–≤–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ m10 –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π —Å—É–º–º—É X –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —Ç–æ—á–µ–∫
    dM10 = moments['m10']
    # –ú–æ–º–µ–Ω—Ç –Ω—É–ª–µ–≤–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ m00 ‚Äî —ç—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—Å–µ—Ö —Ç–æ—á–µ–∫, —Å–æ—Å—Ç–∞–≤–ª—è—é—â–∏—Ö –ø—è—Ç–Ω–æ
    dArea = moments['m00']

    # –ï—Å–ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∏–∫—Å–µ–ª–µ–π –ø—è—Ç–Ω–∞ > 100
    if dArea > 100:
        # –°—Ä–µ–¥–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã X –∏ Y - —Ü–µ–Ω—Ç—Ä –ø—è—Ç–Ω–∞
        x = int(dM10 / dArea)
        y = int(dM01 / dArea)
        cv2.circle(img, (x, y), 5, (0,255,255), 2)
        cv2.putText(img, "%d-%d" % (x,y), (x+10,y-10), cv2.FONT_HERSHEY_SIMPLEX, 1, (0,255,255), 2)

        # –Ω–∞–ø–æ–ª–Ω—è–µ–º –º–∞—Å—Å–∏–≤—ã –∑–Ω–∞—á–µ–Ω–∏–µ—è–º–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —Ü–µ–Ω—Ç—Ä–∞ –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏
        #array(x, y)
    '''
    return (thresh)

if __name__ == '__main__':

    if args["coordinat"] is not None:
        cap = cv2.VideoCapture(args["coordinat"])

        _, frame = cap.read()

        plt.imshow(frame)
        plt.show()

    if args["predict"] is not None:
        predict(args["predict"])

    if args["range"] is not None:
        range(args["range"])

    if args["ball"] is not None:
        cap = cv2.VideoCapture(args["ball"])

        #cv2.namedWindow( "result" )

        # –º–∞—Å—Å–∏–≤ –¥–ª—è –∑–∞–ø–∏—Å–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —Ü–µ–Ω—Ç—Ä–∞
        # –¥–ª—è –ª–∏–Ω–µ–π–Ω–æ–π —Ä–µ–≥—Ä–µ—Å—Å–∏–∏
        data_x = []
        data_y = []

        # –ì—Ä–∞–Ω–∏—Ü—ã –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ä–∞–Ω–µ–µ —Ü–≤–µ—Ç–∞
        minb = color_range.MINB
        ming = color_range.MING
        minr = color_range.MINR
        maxb = color_range.MAXB
        maxg = color_range.MAXG
        maxr = color_range.MAXR
        hsv_min = np.array((minb, ming, minr), np.uint8)
        hsv_max = np.array((maxb, maxg, maxr), np.uint8)

        while(cap.isOpened()):
            _, frame = cap.read()
            #img = cv2.flip(frame,1) # –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ –∫–∞–¥—Ä–∞ –≤–¥–æ–ª—å –æ—Å–∏ Y
            img = np.copy(frame)

            thresh = color(img, hsv_min, hsv_max)

            image_circle = ball(thresh, img)

            cv2.imshow('image ', image_circle)

            #cv2.imshow('result', img)
            cv2.imshow('thresh ', thresh)

            if cv2.waitKey(1) & 0xFF == ord('q'):
                break

        cap.release()
        cv2.destroyAllWindows()
